// Code generated by ogen, DO NOT EDIT.

package bawards

import (
	"context"
	"net/url"
	"strings"
	"time"

	"github.com/go-faster/errors"
	"go.opentelemetry.io/otel/attribute"
	"go.opentelemetry.io/otel/codes"
	"go.opentelemetry.io/otel/metric"
	semconv "go.opentelemetry.io/otel/semconv/v1.19.0"
	"go.opentelemetry.io/otel/trace"

	"github.com/ogen-go/ogen/conv"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/ogenerrors"
	"github.com/ogen-go/ogen/otelogen"
	"github.com/ogen-go/ogen/uri"
)

// Invoker invokes operations described by OpenAPI v3 specification.
type Invoker interface {
	// AwardsList invokes AwardsList operation.
	//
	// Список наград, выдаваемых за достижение уровеней по
	// традициям и инструментам.
	//
	// GET /awards
	AwardsList(ctx context.Context, params AwardsListParams) (*AwardsListOKHeaders, error)
	// ChallengesList invokes ChallengesList operation.
	//
	// Список испытаний.
	//
	// GET /challenges
	ChallengesList(ctx context.Context, params ChallengesListParams) (*ChallengesListOKHeaders, error)
	// ComplexChallengeCreate invokes ComplexChallengeCreate operation.
	//
	// > Достуно только для администрации.
	//
	// POST /complexch
	ComplexChallengeCreate(ctx context.Context, request *ComplexChallengeCreateReq) (ComplexChallengeCreateRes, error)
	// ComplexChallengeGoalCreate invokes ComplexChallengeGoalCreate operation.
	//
	// > Достуно только для администрации.
	//
	// POST /complexch/{complexch_id}/goals
	ComplexChallengeGoalCreate(ctx context.Context, request *ComplexChallengeGoalCreateReq, params ComplexChallengeGoalCreateParams) (ComplexChallengeGoalCreateRes, error)
	// ComplexChallengeGoalDelete invokes ComplexChallengeGoalDelete operation.
	//
	// > Достуно только для администрации.
	//
	// DELETE /complexch/goals/{goal_id}
	ComplexChallengeGoalDelete(ctx context.Context, params ComplexChallengeGoalDeleteParams) (ComplexChallengeGoalDeleteRes, error)
	// ComplexChallengeGoalRead invokes ComplexChallengeGoalRead operation.
	//
	// > Достуно только для администрации.
	//
	// GET /complexch/goals/{goal_id}
	ComplexChallengeGoalRead(ctx context.Context, params ComplexChallengeGoalReadParams) (ComplexChallengeGoalReadRes, error)
	// ComplexChallengeGoalUpdate invokes ComplexChallengeGoalUpdate operation.
	//
	// > Достуно только для администрации.
	//
	// PATCH /complexch/goals/{goal_id}
	ComplexChallengeGoalUpdate(ctx context.Context, request *ComplexChallengeGoalFields, params ComplexChallengeGoalUpdateParams) (ComplexChallengeGoalUpdateRes, error)
	// ComplexChallengeGoalsList invokes ComplexChallengeGoalsList operation.
	//
	// > Достуно только для администрации.
	//
	// GET /complexch/{complexch_id}/goals
	ComplexChallengeGoalsList(ctx context.Context, params ComplexChallengeGoalsListParams) (ComplexChallengeGoalsListRes, error)
	// ComplexChallengePublic invokes ComplexChallengePublic operation.
	//
	// > Достуно только для администрации.
	// Смена состояния на опубликованное требует
	// выполнение валидации испытания и его целей.
	// Подробнее см. в описании операции
	// [ComplexChallengeValidate](#tag/complexch/operation/ComplexChallengeValidate).
	//
	// PUT /complexch/{complexch_id}/public
	ComplexChallengePublic(ctx context.Context, params ComplexChallengePublicParams) (ComplexChallengePublicRes, error)
	// ComplexChallengeRead invokes ComplexChallengeRead operation.
	//
	// Наличие полей `score_formula` и `required_score` зависит от наличия
	// административных прав.
	// Для массива `goals` так же требуются административные
	// права, а так же явный запрос этого свойства.
	//
	// GET /complexch/{complexch_id}
	ComplexChallengeRead(ctx context.Context, params ComplexChallengeReadParams) (ComplexChallengeReadRes, error)
	// ComplexChallengeUpdate invokes ComplexChallengeUpdate operation.
	//
	// > Достуно только для администрации.
	//
	// PATCH /complexch/{complexch_id}
	ComplexChallengeUpdate(ctx context.Context, request *ComplexChallengeUpdateReq, params ComplexChallengeUpdateParams) (ComplexChallengeUpdateRes, error)
	// ComplexChallengeValidate invokes ComplexChallengeValidate operation.
	//
	// > Достуно только для администрации.
	// Ошибки валидации включают в себя массив полей
	// относящихся к ошибке.
	// Эти поля содержат путь до ошибки, в котором точка
	// является разделителем.
	// > К примеру, ошибка связанная с целью `ID=23` будет иметь
	// путь `goals.23`.
	// >
	// > А ошибка с связанная с полем `required_score` цели `ID=23`: `goals.23.
	// required_score`.
	// Поля самого испытания не содержат префиксов, а только
	// имена самих полей.
	//
	// POST /complexch/{complexch_id}/validate
	ComplexChallengeValidate(ctx context.Context, params ComplexChallengeValidateParams) (ComplexChallengeValidateRes, error)
	// ComplexChallengesList invokes ComplexChallengesList operation.
	//
	// Список агрегатных испытаний.
	//
	// GET /complexch
	ComplexChallengesList(ctx context.Context, params ComplexChallengesListParams) (*ComplexChallengesListOKHeaders, error)
	// ComplexChallengesResultsList invokes ComplexChallengesResultsList operation.
	//
	// Список результатов прохождения агрегатных испытаний.
	//
	// GET /complexch/results
	ComplexChallengesResultsList(ctx context.Context, params ComplexChallengesResultsListParams) (ComplexChallengesResultsListRes, error)
	// FormulaParse invokes FormulaParse operation.
	//
	// > Достуно только для администрации.
	// Формула представляется в форме строки
	// последовательности операций,
	// группируемых круглыми скобками в дерево таких
	// последовательностей.
	// Формулы имеют разное назначение, в следствии чего, и
	// разный контекст вычисления.
	// Но все они в результате вычисления имеют только одно
	// числовое значение.
	// В комплексных испытаниях итоговый балл вычисляется
	// формулой для одного кортежа,
	// которая вычисляет итоговый балл на основе переменных
	// полученных в результате агрегаций.
	// А ниже уровнем, в целях испытания, агрегатные формулы
	// вычисляют значения этих переменных.
	// ### Агрегатные формулы для множества кортежей
	// Агрегатные формулы вычисляются в отношении
	// множества кортежей с активностями.
	// Эти формулы могут обращаться к свойствам активностей
	// и их метрикам только через агрегатные функции.
	// Такие формулы используются для вычисления значений
	// переменных,
	// объявленных для целей комплексных испытаний.
	// ### Формулы вычисления из переменных одного кортежа
	// Такие формулы используются для вычисления итогового
	// балла испытания.
	// В рамках вычисления используются числовые
	// переменные из целей.
	// Значение каждой из переменных представлено в
	// единичном числе.
	// В следствии чего, агрегатные функции в такой формуле
	// не имеют смысла,
	// а их упоминание в ней вызовет ошибку валидации.
	//
	// POST /formula
	FormulaParse(ctx context.Context, request *FormulaParseReq) (FormulaParseRes, error)
	// InstrumentCreate invokes InstrumentCreate operation.
	//
	// Добавление инструмента.
	//
	// POST /instruments
	InstrumentCreate(ctx context.Context, request *InstrumentCreateRequest) (InstrumentCreateRes, error)
	// InstrumentRead invokes InstrumentRead operation.
	//
	// Инструмент.
	//
	// GET /instruments/{instrument_id}
	InstrumentRead(ctx context.Context, params InstrumentReadParams) (InstrumentReadRes, error)
	// InstrumentUpdate invokes InstrumentUpdate operation.
	//
	// Обновление инструмента.
	//
	// PATCH /instruments/{instrument_id}
	InstrumentUpdate(ctx context.Context, request *InstrumentUpdateRequest, params InstrumentUpdateParams) (InstrumentUpdateRes, error)
	// InstrumentsList invokes InstrumentsList operation.
	//
	// Список инструментов.
	//
	// GET /instruments
	InstrumentsList(ctx context.Context, params InstrumentsListParams) (*InstrumentsListOKHeaders, error)
	// PassedChallengesList invokes PassedChallengesList operation.
	//
	// > При аутентификации токеном `TalentOAuth`,
	// предустанавливается параметр `talent_id`.
	// > При аутентификации токеном `BerlogaJWT`,
	// предустанавливается параметр `player_id`.
	// Обязателен для заполнения один из параметров `player_id` и
	// `talent_id`.
	//
	// GET /challenges/passed
	PassedChallengesList(ctx context.Context, params PassedChallengesListParams) (PassedChallengesListRes, error)
	// TraditionCreate invokes TraditionCreate operation.
	//
	// Добавление традиции.
	//
	// POST /traditions
	TraditionCreate(ctx context.Context, request *TraditionCreateRequest) (TraditionCreateRes, error)
	// TraditionInstrumentsList invokes TraditionInstrumentsList operation.
	//
	// Список инструментов традиции.
	//
	// GET /traditions/{tradition_id}/instruments
	TraditionInstrumentsList(ctx context.Context, params TraditionInstrumentsListParams) ([]Instrument, error)
	// TraditionRead invokes TraditionRead operation.
	//
	// Традиция.
	//
	// GET /traditions/{tradition_id}
	TraditionRead(ctx context.Context, params TraditionReadParams) (TraditionReadRes, error)
	// TraditionUpdate invokes TraditionUpdate operation.
	//
	// Обновление традиции.
	//
	// PATCH /traditions/{tradition_id}
	TraditionUpdate(ctx context.Context, request *TraditionUpdateRequest, params TraditionUpdateParams) (TraditionUpdateRes, error)
	// TraditionsList invokes TraditionsList operation.
	//
	// Список традиций.
	//
	// GET /traditions
	TraditionsList(ctx context.Context, params TraditionsListParams) ([]Tradition, error)
	// UserAwardDisplayed invokes UserAwardDisplayed operation.
	//
	// Отметка награды как продемонстрированной
	// пользователю в приложении.
	//
	// POST /user-awards/{award_id}/displayed
	UserAwardDisplayed(ctx context.Context, params UserAwardDisplayedParams) error
	// UserAwardsList invokes UserAwardsList operation.
	//
	// Формат возвращаемых объектов в массиве зависит от
	// типа используемой авторизации. Для `BerlogaJWT`
	// возращаются `PlayerAward`, для `TalentOAuth` - `TalentUserAward`.
	//
	// GET /user-awards
	UserAwardsList(ctx context.Context, params UserAwardsListParams) (*UserAwardsListOKHeaders, error)
	// UserProgressList invokes UserProgressList operation.
	//
	// Прогресс пользователя по традициям и инструментам.
	//
	// GET /user-progress
	UserProgressList(ctx context.Context, params UserProgressListParams) (*UserProgressListOKHeaders, error)
}

// Client implements OAS client.
type Client struct {
	serverURL *url.URL
	sec       SecuritySource
	baseClient
}

func trimTrailingSlashes(u *url.URL) {
	u.Path = strings.TrimRight(u.Path, "/")
	u.RawPath = strings.TrimRight(u.RawPath, "/")
}

// NewClient initializes new Client defined by OAS.
func NewClient(serverURL string, sec SecuritySource, opts ...ClientOption) (*Client, error) {
	u, err := url.Parse(serverURL)
	if err != nil {
		return nil, err
	}
	trimTrailingSlashes(u)

	c, err := newClientConfig(opts...).baseClient()
	if err != nil {
		return nil, err
	}
	return &Client{
		serverURL:  u,
		sec:        sec,
		baseClient: c,
	}, nil
}

type serverURLKey struct{}

// WithServerURL sets context key to override server URL.
func WithServerURL(ctx context.Context, u *url.URL) context.Context {
	return context.WithValue(ctx, serverURLKey{}, u)
}

func (c *Client) requestURL(ctx context.Context) *url.URL {
	u, ok := ctx.Value(serverURLKey{}).(*url.URL)
	if !ok {
		return c.serverURL
	}
	return u
}

// AwardsList invokes AwardsList operation.
//
// Список наград, выдаваемых за достижение уровеней по
// традициям и инструментам.
//
// GET /awards
func (c *Client) AwardsList(ctx context.Context, params AwardsListParams) (*AwardsListOKHeaders, error) {
	res, err := c.sendAwardsList(ctx, params)
	return res, err
}

func (c *Client) sendAwardsList(ctx context.Context, params AwardsListParams) (res *AwardsListOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("AwardsList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/awards"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "AwardsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/awards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tradition_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tradition_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TraditionID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "instrument_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "instrument_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.InstrumentID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "with_applications" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_applications",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithApplications.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeAwardsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ChallengesList invokes ChallengesList operation.
//
// Список испытаний.
//
// GET /challenges
func (c *Client) ChallengesList(ctx context.Context, params ChallengesListParams) (*ChallengesListOKHeaders, error) {
	res, err := c.sendChallengesList(ctx, params)
	return res, err
}

func (c *Client) sendChallengesList(ctx context.Context, params ChallengesListParams) (res *ChallengesListOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ChallengesList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/challenges"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ChallengesList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/challenges"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeChallengesListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeCreate invokes ComplexChallengeCreate operation.
//
// > Достуно только для администрации.
//
// POST /complexch
func (c *Client) ComplexChallengeCreate(ctx context.Context, request *ComplexChallengeCreateReq) (ComplexChallengeCreateRes, error) {
	res, err := c.sendComplexChallengeCreate(ctx, request)
	return res, err
}

func (c *Client) sendComplexChallengeCreate(ctx context.Context, request *ComplexChallengeCreateReq) (res ComplexChallengeCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeCreate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/complexch"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/complexch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeComplexChallengeCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeGoalCreate invokes ComplexChallengeGoalCreate operation.
//
// > Достуно только для администрации.
//
// POST /complexch/{complexch_id}/goals
func (c *Client) ComplexChallengeGoalCreate(ctx context.Context, request *ComplexChallengeGoalCreateReq, params ComplexChallengeGoalCreateParams) (ComplexChallengeGoalCreateRes, error) {
	res, err := c.sendComplexChallengeGoalCreate(ctx, request, params)
	return res, err
}

func (c *Client) sendComplexChallengeGoalCreate(ctx context.Context, request *ComplexChallengeGoalCreateReq, params ComplexChallengeGoalCreateParams) (res ComplexChallengeGoalCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeGoalCreate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/complexch/{complexch_id}/goals"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeGoalCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/complexch/"
	{
		// Encode "complexch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complexch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ComplexchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/goals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeComplexChallengeGoalCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeGoalCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeGoalCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeGoalDelete invokes ComplexChallengeGoalDelete operation.
//
// > Достуно только для администрации.
//
// DELETE /complexch/goals/{goal_id}
func (c *Client) ComplexChallengeGoalDelete(ctx context.Context, params ComplexChallengeGoalDeleteParams) (ComplexChallengeGoalDeleteRes, error) {
	res, err := c.sendComplexChallengeGoalDelete(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengeGoalDelete(ctx context.Context, params ComplexChallengeGoalDeleteParams) (res ComplexChallengeGoalDeleteRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeGoalDelete"),
		semconv.HTTPMethodKey.String("DELETE"),
		semconv.HTTPRouteKey.String("/complexch/goals/{goal_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeGoalDelete",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/complexch/goals/"
	{
		// Encode "goal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "goal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.GoalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "DELETE", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeGoalDelete", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeGoalDeleteResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeGoalRead invokes ComplexChallengeGoalRead operation.
//
// > Достуно только для администрации.
//
// GET /complexch/goals/{goal_id}
func (c *Client) ComplexChallengeGoalRead(ctx context.Context, params ComplexChallengeGoalReadParams) (ComplexChallengeGoalReadRes, error) {
	res, err := c.sendComplexChallengeGoalRead(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengeGoalRead(ctx context.Context, params ComplexChallengeGoalReadParams) (res ComplexChallengeGoalReadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeGoalRead"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/complexch/goals/{goal_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeGoalRead",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/complexch/goals/"
	{
		// Encode "goal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "goal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.GoalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeGoalRead", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeGoalReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeGoalUpdate invokes ComplexChallengeGoalUpdate operation.
//
// > Достуно только для администрации.
//
// PATCH /complexch/goals/{goal_id}
func (c *Client) ComplexChallengeGoalUpdate(ctx context.Context, request *ComplexChallengeGoalFields, params ComplexChallengeGoalUpdateParams) (ComplexChallengeGoalUpdateRes, error) {
	res, err := c.sendComplexChallengeGoalUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendComplexChallengeGoalUpdate(ctx context.Context, request *ComplexChallengeGoalFields, params ComplexChallengeGoalUpdateParams) (res ComplexChallengeGoalUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeGoalUpdate"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/complexch/goals/{goal_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeGoalUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/complexch/goals/"
	{
		// Encode "goal_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "goal_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.GoalID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeComplexChallengeGoalUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeGoalUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeGoalUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeGoalsList invokes ComplexChallengeGoalsList operation.
//
// > Достуно только для администрации.
//
// GET /complexch/{complexch_id}/goals
func (c *Client) ComplexChallengeGoalsList(ctx context.Context, params ComplexChallengeGoalsListParams) (ComplexChallengeGoalsListRes, error) {
	res, err := c.sendComplexChallengeGoalsList(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengeGoalsList(ctx context.Context, params ComplexChallengeGoalsListParams) (res ComplexChallengeGoalsListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeGoalsList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/complexch/{complexch_id}/goals"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeGoalsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/complexch/"
	{
		// Encode "complexch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complexch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ComplexchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/goals"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeGoalsList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeGoalsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengePublic invokes ComplexChallengePublic operation.
//
// > Достуно только для администрации.
// Смена состояния на опубликованное требует
// выполнение валидации испытания и его целей.
// Подробнее см. в описании операции
// [ComplexChallengeValidate](#tag/complexch/operation/ComplexChallengeValidate).
//
// PUT /complexch/{complexch_id}/public
func (c *Client) ComplexChallengePublic(ctx context.Context, params ComplexChallengePublicParams) (ComplexChallengePublicRes, error) {
	res, err := c.sendComplexChallengePublic(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengePublic(ctx context.Context, params ComplexChallengePublicParams) (res ComplexChallengePublicRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengePublic"),
		semconv.HTTPMethodKey.String("PUT"),
		semconv.HTTPRouteKey.String("/complexch/{complexch_id}/public"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengePublic",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/complexch/"
	{
		// Encode "complexch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complexch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ComplexchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/public"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "value" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "value",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeValue(conv.BoolToString(params.Value))
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PUT", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengePublic", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengePublicResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeRead invokes ComplexChallengeRead operation.
//
// Наличие полей `score_formula` и `required_score` зависит от наличия
// административных прав.
// Для массива `goals` так же требуются административные
// права, а так же явный запрос этого свойства.
//
// GET /complexch/{complexch_id}
func (c *Client) ComplexChallengeRead(ctx context.Context, params ComplexChallengeReadParams) (ComplexChallengeReadRes, error) {
	res, err := c.sendComplexChallengeRead(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengeRead(ctx context.Context, params ComplexChallengeReadParams) (res ComplexChallengeReadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeRead"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/complexch/{complexch_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeRead",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/complexch/"
	{
		// Encode "complexch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complexch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ComplexchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "with_goals" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "with_goals",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.WithGoals.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeRead", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeUpdate invokes ComplexChallengeUpdate operation.
//
// > Достуно только для администрации.
//
// PATCH /complexch/{complexch_id}
func (c *Client) ComplexChallengeUpdate(ctx context.Context, request *ComplexChallengeUpdateReq, params ComplexChallengeUpdateParams) (ComplexChallengeUpdateRes, error) {
	res, err := c.sendComplexChallengeUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendComplexChallengeUpdate(ctx context.Context, request *ComplexChallengeUpdateReq, params ComplexChallengeUpdateParams) (res ComplexChallengeUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeUpdate"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/complexch/{complexch_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/complexch/"
	{
		// Encode "complexch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complexch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ComplexchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeComplexChallengeUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengeValidate invokes ComplexChallengeValidate operation.
//
// > Достуно только для администрации.
// Ошибки валидации включают в себя массив полей
// относящихся к ошибке.
// Эти поля содержат путь до ошибки, в котором точка
// является разделителем.
// > К примеру, ошибка связанная с целью `ID=23` будет иметь
// путь `goals.23`.
// >
// > А ошибка с связанная с полем `required_score` цели `ID=23`: `goals.23.
// required_score`.
// Поля самого испытания не содержат префиксов, а только
// имена самих полей.
//
// POST /complexch/{complexch_id}/validate
func (c *Client) ComplexChallengeValidate(ctx context.Context, params ComplexChallengeValidateParams) (ComplexChallengeValidateRes, error) {
	res, err := c.sendComplexChallengeValidate(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengeValidate(ctx context.Context, params ComplexChallengeValidateParams) (res ComplexChallengeValidateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengeValidate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/complexch/{complexch_id}/validate"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengeValidate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/complexch/"
	{
		// Encode "complexch_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "complexch_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.ComplexchID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/validate"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "ComplexChallengeValidate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengeValidateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengesList invokes ComplexChallengesList operation.
//
// Список агрегатных испытаний.
//
// GET /complexch
func (c *Client) ComplexChallengesList(ctx context.Context, params ComplexChallengesListParams) (*ComplexChallengesListOKHeaders, error) {
	res, err := c.sendComplexChallengesList(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengesList(ctx context.Context, params ComplexChallengesListParams) (res *ComplexChallengesListOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengesList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/complexch"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengesList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/complexch"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "after" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "public" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "public",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Public.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengesListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// ComplexChallengesResultsList invokes ComplexChallengesResultsList operation.
//
// Список результатов прохождения агрегатных испытаний.
//
// GET /complexch/results
func (c *Client) ComplexChallengesResultsList(ctx context.Context, params ComplexChallengesResultsListParams) (ComplexChallengesResultsListRes, error) {
	res, err := c.sendComplexChallengesResultsList(ctx, params)
	return res, err
}

func (c *Client) sendComplexChallengesResultsList(ctx context.Context, params ComplexChallengesResultsListParams) (res ComplexChallengesResultsListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("ComplexChallengesResultsList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/complexch/results"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "ComplexChallengesResultsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/complexch/results"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "after" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.Int64ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "user_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "user_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.UserID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeComplexChallengesResultsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// FormulaParse invokes FormulaParse operation.
//
// > Достуно только для администрации.
// Формула представляется в форме строки
// последовательности операций,
// группируемых круглыми скобками в дерево таких
// последовательностей.
// Формулы имеют разное назначение, в следствии чего, и
// разный контекст вычисления.
// Но все они в результате вычисления имеют только одно
// числовое значение.
// В комплексных испытаниях итоговый балл вычисляется
// формулой для одного кортежа,
// которая вычисляет итоговый балл на основе переменных
// полученных в результате агрегаций.
// А ниже уровнем, в целях испытания, агрегатные формулы
// вычисляют значения этих переменных.
// ### Агрегатные формулы для множества кортежей
// Агрегатные формулы вычисляются в отношении
// множества кортежей с активностями.
// Эти формулы могут обращаться к свойствам активностей
// и их метрикам только через агрегатные функции.
// Такие формулы используются для вычисления значений
// переменных,
// объявленных для целей комплексных испытаний.
// ### Формулы вычисления из переменных одного кортежа
// Такие формулы используются для вычисления итогового
// балла испытания.
// В рамках вычисления используются числовые
// переменные из целей.
// Значение каждой из переменных представлено в
// единичном числе.
// В следствии чего, агрегатные функции в такой формуле
// не имеют смысла,
// а их упоминание в ней вызовет ошибку валидации.
//
// POST /formula
func (c *Client) FormulaParse(ctx context.Context, request *FormulaParseReq) (FormulaParseRes, error) {
	res, err := c.sendFormulaParse(ctx, request)
	return res, err
}

func (c *Client) sendFormulaParse(ctx context.Context, request *FormulaParseReq) (res FormulaParseRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("FormulaParse"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/formula"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "FormulaParse",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/formula"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeFormulaParseRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "FormulaParse", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeFormulaParseResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentCreate invokes InstrumentCreate operation.
//
// Добавление инструмента.
//
// POST /instruments
func (c *Client) InstrumentCreate(ctx context.Context, request *InstrumentCreateRequest) (InstrumentCreateRes, error) {
	res, err := c.sendInstrumentCreate(ctx, request)
	return res, err
}

func (c *Client) sendInstrumentCreate(ctx context.Context, request *InstrumentCreateRequest) (res InstrumentCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentCreate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/instruments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/instruments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "InstrumentCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentRead invokes InstrumentRead operation.
//
// Инструмент.
//
// GET /instruments/{instrument_id}
func (c *Client) InstrumentRead(ctx context.Context, params InstrumentReadParams) (InstrumentReadRes, error) {
	res, err := c.sendInstrumentRead(ctx, params)
	return res, err
}

func (c *Client) sendInstrumentRead(ctx context.Context, params InstrumentReadParams) (res InstrumentReadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentRead"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/instruments/{instrument_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentRead",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/instruments/"
	{
		// Encode "instrument_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instrument_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.InstrumentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentUpdate invokes InstrumentUpdate operation.
//
// Обновление инструмента.
//
// PATCH /instruments/{instrument_id}
func (c *Client) InstrumentUpdate(ctx context.Context, request *InstrumentUpdateRequest, params InstrumentUpdateParams) (InstrumentUpdateRes, error) {
	res, err := c.sendInstrumentUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendInstrumentUpdate(ctx context.Context, request *InstrumentUpdateRequest, params InstrumentUpdateParams) (res InstrumentUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentUpdate"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/instruments/{instrument_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/instruments/"
	{
		// Encode "instrument_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "instrument_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.InstrumentID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeInstrumentUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "InstrumentUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// InstrumentsList invokes InstrumentsList operation.
//
// Список инструментов.
//
// GET /instruments
func (c *Client) InstrumentsList(ctx context.Context, params InstrumentsListParams) (*InstrumentsListOKHeaders, error) {
	res, err := c.sendInstrumentsList(ctx, params)
	return res, err
}

func (c *Client) sendInstrumentsList(ctx context.Context, params InstrumentsListParams) (res *InstrumentsListOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("InstrumentsList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/instruments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "InstrumentsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/instruments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "after" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "after",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.After.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "is_active" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "is_active",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsActive.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.ID {
					if err := func() error {
						return e.EncodeValue(conv.Int32ToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "t_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "t_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.TID {
					if err := func() error {
						return e.EncodeValue(conv.Int32ToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "c_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "c_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.CID {
					if err := func() error {
						return e.EncodeValue(conv.Int32ToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeInstrumentsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// PassedChallengesList invokes PassedChallengesList operation.
//
// > При аутентификации токеном `TalentOAuth`,
// предустанавливается параметр `talent_id`.
// > При аутентификации токеном `BerlogaJWT`,
// предустанавливается параметр `player_id`.
// Обязателен для заполнения один из параметров `player_id` и
// `talent_id`.
//
// GET /challenges/passed
func (c *Client) PassedChallengesList(ctx context.Context, params PassedChallengesListParams) (PassedChallengesListRes, error) {
	res, err := c.sendPassedChallengesList(ctx, params)
	return res, err
}

func (c *Client) sendPassedChallengesList(ctx context.Context, params PassedChallengesListParams) (res PassedChallengesListRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("PassedChallengesList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/challenges/passed"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "PassedChallengesList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/challenges/passed"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "player_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "player_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.PlayerID.Get(); ok {
				return e.EncodeValue(conv.UUIDToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "talent_id" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "talent_id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TalentID.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "PassedChallengesList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}
		{
			stage = "Security:BerlogaJWT"
			switch err := c.securityBerlogaJWT(ctx, "PassedChallengesList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BerlogaJWT\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
				{},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodePassedChallengesListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TraditionCreate invokes TraditionCreate operation.
//
// Добавление традиции.
//
// POST /traditions
func (c *Client) TraditionCreate(ctx context.Context, request *TraditionCreateRequest) (TraditionCreateRes, error) {
	res, err := c.sendTraditionCreate(ctx, request)
	return res, err
}

func (c *Client) sendTraditionCreate(ctx context.Context, request *TraditionCreateRequest) (res TraditionCreateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("TraditionCreate"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/traditions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TraditionCreate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/traditions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTraditionCreateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "TraditionCreate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTraditionCreateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TraditionInstrumentsList invokes TraditionInstrumentsList operation.
//
// Список инструментов традиции.
//
// GET /traditions/{tradition_id}/instruments
func (c *Client) TraditionInstrumentsList(ctx context.Context, params TraditionInstrumentsListParams) ([]Instrument, error) {
	res, err := c.sendTraditionInstrumentsList(ctx, params)
	return res, err
}

func (c *Client) sendTraditionInstrumentsList(ctx context.Context, params TraditionInstrumentsListParams) (res []Instrument, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("TraditionInstrumentsList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/traditions/{tradition_id}/instruments"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TraditionInstrumentsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/traditions/"
	{
		// Encode "tradition_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tradition_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.TraditionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/instruments"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTraditionInstrumentsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TraditionRead invokes TraditionRead operation.
//
// Традиция.
//
// GET /traditions/{tradition_id}
func (c *Client) TraditionRead(ctx context.Context, params TraditionReadParams) (TraditionReadRes, error) {
	res, err := c.sendTraditionRead(ctx, params)
	return res, err
}

func (c *Client) sendTraditionRead(ctx context.Context, params TraditionReadParams) (res TraditionReadRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("TraditionRead"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/traditions/{tradition_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TraditionRead",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/traditions/"
	{
		// Encode "tradition_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tradition_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.TraditionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTraditionReadResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TraditionUpdate invokes TraditionUpdate operation.
//
// Обновление традиции.
//
// PATCH /traditions/{tradition_id}
func (c *Client) TraditionUpdate(ctx context.Context, request *TraditionUpdateRequest, params TraditionUpdateParams) (TraditionUpdateRes, error) {
	res, err := c.sendTraditionUpdate(ctx, request, params)
	return res, err
}

func (c *Client) sendTraditionUpdate(ctx context.Context, request *TraditionUpdateRequest, params TraditionUpdateParams) (res TraditionUpdateRes, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("TraditionUpdate"),
		semconv.HTTPMethodKey.String("PATCH"),
		semconv.HTTPRouteKey.String("/traditions/{tradition_id}"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TraditionUpdate",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [2]string
	pathParts[0] = "/traditions/"
	{
		// Encode "tradition_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "tradition_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.TraditionID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "PATCH", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}
	if err := encodeTraditionUpdateRequest(request, r); err != nil {
		return res, errors.Wrap(err, "encode request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "TraditionUpdate", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTraditionUpdateResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// TraditionsList invokes TraditionsList operation.
//
// Список традиций.
//
// GET /traditions
func (c *Client) TraditionsList(ctx context.Context, params TraditionsListParams) ([]Tradition, error) {
	res, err := c.sendTraditionsList(ctx, params)
	return res, err
}

func (c *Client) sendTraditionsList(ctx context.Context, params TraditionsListParams) (res []Tradition, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("TraditionsList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/traditions"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "TraditionsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/traditions"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "name" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "name",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Name.Get(); ok {
				return e.EncodeValue(conv.StringToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "is_active" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "is_active",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.IsActive.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeTraditionsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserAwardDisplayed invokes UserAwardDisplayed operation.
//
// Отметка награды как продемонстрированной
// пользователю в приложении.
//
// POST /user-awards/{award_id}/displayed
func (c *Client) UserAwardDisplayed(ctx context.Context, params UserAwardDisplayedParams) error {
	_, err := c.sendUserAwardDisplayed(ctx, params)
	return err
}

func (c *Client) sendUserAwardDisplayed(ctx context.Context, params UserAwardDisplayedParams) (res *UserAwardDisplayedOK, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UserAwardDisplayed"),
		semconv.HTTPMethodKey.String("POST"),
		semconv.HTTPRouteKey.String("/user-awards/{award_id}/displayed"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserAwardDisplayed",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [3]string
	pathParts[0] = "/user-awards/"
	{
		// Encode "award_id" parameter.
		e := uri.NewPathEncoder(uri.PathEncoderConfig{
			Param:   "award_id",
			Style:   uri.PathStyleSimple,
			Explode: false,
		})
		if err := func() error {
			return e.EncodeValue(conv.Int32ToString(params.AwardID))
		}(); err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		encoded, err := e.Result()
		if err != nil {
			return res, errors.Wrap(err, "encode path")
		}
		pathParts[1] = encoded
	}
	pathParts[2] = "/displayed"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "POST", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:BerlogaJWT"
			switch err := c.securityBerlogaJWT(ctx, "UserAwardDisplayed", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BerlogaJWT\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserAwardDisplayedResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserAwardsList invokes UserAwardsList operation.
//
// Формат возвращаемых объектов в массиве зависит от
// типа используемой авторизации. Для `BerlogaJWT`
// возращаются `PlayerAward`, для `TalentOAuth` - `TalentUserAward`.
//
// GET /user-awards
func (c *Client) UserAwardsList(ctx context.Context, params UserAwardsListParams) (*UserAwardsListOKHeaders, error) {
	res, err := c.sendUserAwardsList(ctx, params)
	return res, err
}

func (c *Client) sendUserAwardsList(ctx context.Context, params UserAwardsListParams) (res *UserAwardsListOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UserAwardsList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user-awards"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserAwardsList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user-awards"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "UserAwardsList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}
		{
			stage = "Security:BerlogaJWT"
			switch err := c.securityBerlogaJWT(ctx, "UserAwardsList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BerlogaJWT\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserAwardsListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}

// UserProgressList invokes UserProgressList operation.
//
// Прогресс пользователя по традициям и инструментам.
//
// GET /user-progress
func (c *Client) UserProgressList(ctx context.Context, params UserProgressListParams) (*UserProgressListOKHeaders, error) {
	res, err := c.sendUserProgressList(ctx, params)
	return res, err
}

func (c *Client) sendUserProgressList(ctx context.Context, params UserProgressListParams) (res *UserProgressListOKHeaders, err error) {
	otelAttrs := []attribute.KeyValue{
		otelogen.OperationID("UserProgressList"),
		semconv.HTTPMethodKey.String("GET"),
		semconv.HTTPRouteKey.String("/user-progress"),
	}

	// Run stopwatch.
	startTime := time.Now()
	defer func() {
		// Use floating point division here for higher precision (instead of Millisecond method).
		elapsedDuration := time.Since(startTime)
		c.duration.Record(ctx, float64(float64(elapsedDuration)/float64(time.Millisecond)), metric.WithAttributes(otelAttrs...))
	}()

	// Increment request counter.
	c.requests.Add(ctx, 1, metric.WithAttributes(otelAttrs...))

	// Start a span for this request.
	ctx, span := c.cfg.Tracer.Start(ctx, "UserProgressList",
		trace.WithAttributes(otelAttrs...),
		clientSpanKind,
	)
	// Track stage for error reporting.
	var stage string
	defer func() {
		if err != nil {
			span.RecordError(err)
			span.SetStatus(codes.Error, stage)
			c.errors.Add(ctx, 1, metric.WithAttributes(otelAttrs...))
		}
		span.End()
	}()

	stage = "BuildURL"
	u := uri.Clone(c.requestURL(ctx))
	var pathParts [1]string
	pathParts[0] = "/user-progress"
	uri.AddPathParts(u, pathParts[:]...)

	stage = "EncodeQueryParams"
	q := uri.NewQueryEncoder()
	{
		// Encode "offset" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Offset.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "limit" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.Limit.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "traditions_only" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "traditions_only",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TraditionsOnly.Get(); ok {
				return e.EncodeValue(conv.BoolToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tradition_instruments" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tradition_instruments",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.TraditionInstruments.Get(); ok {
				return e.EncodeValue(conv.Int32ToString(val))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "tradition_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "tradition_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.TraditionIds {
					if err := func() error {
						return e.EncodeValue(conv.Int32ToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "instrument_ids" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "instrument_ids",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			return e.EncodeArray(func(e uri.Encoder) error {
				for i, item := range params.InstrumentIds {
					if err := func() error {
						return e.EncodeValue(conv.Int32ToString(item))
					}(); err != nil {
						return errors.Wrapf(err, "[%d]", i)
					}
				}
				return nil
			})
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	{
		// Encode "order_by" parameter.
		cfg := uri.QueryParameterEncodingConfig{
			Name:    "order_by",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.EncodeParam(cfg, func(e uri.Encoder) error {
			if val, ok := params.OrderBy.Get(); ok {
				return e.EncodeValue(conv.StringToString(string(val)))
			}
			return nil
		}); err != nil {
			return res, errors.Wrap(err, "encode query")
		}
	}
	u.RawQuery = q.Values().Encode()

	stage = "EncodeRequest"
	r, err := ht.NewRequest(ctx, "GET", u)
	if err != nil {
		return res, errors.Wrap(err, "create request")
	}

	{
		type bitset = [1]uint8
		var satisfied bitset
		{
			stage = "Security:TalentOAuth"
			switch err := c.securityTalentOAuth(ctx, "UserProgressList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 0
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"TalentOAuth\"")
			}
		}
		{
			stage = "Security:BerlogaJWT"
			switch err := c.securityBerlogaJWT(ctx, "UserProgressList", r); {
			case err == nil: // if NO error
				satisfied[0] |= 1 << 1
			case errors.Is(err, ogenerrors.ErrSkipClientSecurity):
				// Skip this security.
			default:
				return res, errors.Wrap(err, "security \"BerlogaJWT\"")
			}
		}

		if ok := func() bool {
		nextRequirement:
			for _, requirement := range []bitset{
				{0b00000001},
				{0b00000010},
			} {
				for i, mask := range requirement {
					if satisfied[i]&mask != mask {
						continue nextRequirement
					}
				}
				return true
			}
			return false
		}(); !ok {
			return res, ogenerrors.ErrSecurityRequirementIsNotSatisfied
		}
	}

	stage = "SendRequest"
	resp, err := c.cfg.Client.Do(r)
	if err != nil {
		return res, errors.Wrap(err, "do request")
	}
	defer resp.Body.Close()

	stage = "DecodeResponse"
	result, err := decodeUserProgressListResponse(resp)
	if err != nil {
		return res, errors.Wrap(err, "decode response")
	}

	return result, nil
}
